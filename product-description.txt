Here's the product I want to build:
A tool that will generate possible states from a description of a
finite state machine. A finite state machine is built by a set of
rules that define transitions from one state to another.

State Definitions:
A state is defined by a set of variables set to specific values. A state also
may also be compared with another state to establish whether they are equivalent.
Two states are equivalent if they share all the same variables set to the same
values.

Rule Definitions:
A rule describes an action or event which will transform a given set of variables
in the given state to a new set of values, which will comprise a new state.
A rule may be queried by passing it a current state definition, to which
the rull will indicate whether it is available.

Rule Implementation:
Rules implement a rule interface. The interface exposes two functions:
 - boolean isAvailable(state) - returns true if the rule is available with the current state
 - state execute(state) - returns a new state derived from executing the given state

State Machine Definition:
A state machine has the following properties
- States - a dictionary of states in the machine where each entry is keyed with an ID
- StartingState - the ID of the first state in the machine
- Transitions - the paths through the machine indicated by a starting and ending
  state ID and the action that causes the transition. The action corresponds to the
  name of the rule that created the transition.

State machine builder:
Implements a machine builder interface. The builder implements the following
functions:
 - StateMachine build(state initialState, Rule[] rules, BuilderConfig configuration)
   Returns a StateMachine built starting from initialSate and applying the rules specified
   the array rules. The configuration specifies behavior settings for the build
   method.

The interfaces for Rule, StateMachineBuilder, as well as the classes State and
BuilderConfig go in the statemaker assembly namespace. The namespace is imported
to allow building of custom rules.

Declarative State Machine Building:
It is possible to declare state machines without writing custom rules. There
will be a set of rules implemented that allow someone to define simple rules by
supplying the following information:
- rule name
- boolean expressions of state variable conditions that make the rule available
- transformation of which variables from original value to new value
There should be an API to call to define rules in this fashion. It should also
be possible to load a definition file describing declarative state machine
building.

Project Considerations:
  
Continuous Integration
This project will use continuous integration with trunk-based development
practices.
- The unit tests need to run and pass prior to merging into trun. This needs
  to be enforced in Github, outside the control of Claude.
- There needs to be a set of static inspection checks to look for code
  coverage and internal code quality checks. These checks must be executed
  and pass prior to merging into trunk.

Continuous Deployment
This project is producing a standalone tool. There is no service deployment.
There will be a release process for the tool. There should be a released
version of the tool binaries available after every build. The default shall
be to treat every change like a minor release until someone specifies otherwise.

The initial product version shall be less than 1.0.0 (semantic versioning)
until specified otherwise.